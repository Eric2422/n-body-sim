import numpy as np
import scipy

from particle import PointParticle


class Wire():
    """A straight current-carrying wire with a specified position, length, and resistance."""

    def __init__(self, points: np.ndarray[np.float64], resistance: np.float64 = 1.0) -> None:
        """Initiate a an current-carrying wire.

        Parameters
        ----------
        points : np.ndarray[np.float64]
            A 2D array of the points that the wire connects.
        resistance : np.float64
            The total resistance of the wire. Greater than 0, by default 1.0
        """
        self.points = points
        self.resistance = resistance

    def get_total_length(self) -> np.float64:
        """Calculate the total length of the wire.

        Returns
        -------
        np.float64
            A scalar value representing the total length of this wire. 
        """
        # Sum the distance between each point
        length = 0
        for i in range(0, len(self.points) - 1):
            length += np.linalg.norm(self.points[i+1] - self.points[i])

        return length

    def sum_wire_segments(self, func):
        """Perform a calculation on each segment of the wire and sum them.

        Parameters
        ----------
        func : function
            A function with a calculation to perform on each segment of the wire
        """
        total = 0

        # Loop through each segment of the wire
        for i in range(len(self.points) - 1):
            # The vector of the space between the points
            wire_vector = self.points[i+1] - self.end1[i]
            unit_vector = wire_vector / np.linalg.norm(wire_vector)

            total += func()

        return total

    def get_electromotive_force(self, particles: list[PointParticle], electric_field: np.ndarray[np.float64]) -> np.float64:
        """Calculate the electromotive force(emf) generated across the wire.

        Parameters
        ----------
        particle : PointParticle
            The particle that is exerting a electric field across the wire.
        electric_field : np.ndarray[float64]
            A constant electric field that is being applied to the wire. 

        Returns
        -------
            The difference in electric potential between the ends of the wires.
        """
        def sum_electric_fields(field_point: np.ndarray[np.float64]) -> np.ndarray[np.float64]:
            """Calculate the net electric field at a given point.

            Parameters
            ----------
            field_point : np.ndarray
                A 3D vector representing the point to calculate the electric field at.

            Returns
            -------
            np.ndarray
                A 3D vector representing the net electric field in V/m or N/C.
            """
            # Find the electric field due to each particle
            electric_fields = map(
                lambda particle: particle.electric_field(
                    field_point), particles
            )

            return sum(electric_fields) + electric_field

        emf = 0

        # Loop through each segment of the wire
        for i in range(len(self.points) - 1):
            print(i)
            # The vector of the space between the points
            wire_vector = self.points[i+1] - self.points[i]
            wire_vector_hat = wire_vector / np.linalg.norm(wire_vector)

            # Negative integral of the electric field across the wire.
            emf += -scipy.integrate.quad(
                lambda l: np.dot(
                        sum_electric_fields(self.points[i] + wire_vector_hat * l), 
                        wire_vector_hat
                    ),
                0,
                self.get_total_length()
            )[0]

        return emf

    def get_current(self) -> np.float64:
        """Calculate the current flowing through this wire.

        Returns
        -------
        np.float64
            The current flowing through the wire in amps.
        """
        return self.electromotive_force() / self.resistance

    def get_magnetic_field(self, field_point: np.ndarray[np.float64]) -> np.ndarray[np.float64]:
        """Calculate the magnetic field generated by this wire at a point.

        Parameters
        ----------
        field_point : np.ndarray
            A 3D vector of np.float64 representing a point to calculate the magnetic field at.

        Returns
        -------
        np.ndarray
            A 3D vector representing the strength of the magnetic field at the point in teslas. 
        """
        def r(l: np.float64, start_point: np.ndarray[np.float64]) -> np.ndarray[np.float64]:
            """Calculate r, the 3D vector between the magnetic field point and the point of integration.

            Parameters
            ----------
            l : np.float64
                The distance along this wire from `start_point` in meters.
            start_point : np.ndarray
                The point that the wire segment starts from.

            Returns
            -------
            np.ndarray
                A 3D vector from the point of integration to `field_point`.
            """
            return field_point - (start_point + l * wire_vector_hat)

        # Loop through each segment of the wire
        for i in range(len(self.points) - 1):
            wire_vector = self.points[i+1] - self.points[i]
            wire_vector_hat = wire_vector / np.linalg.norm(wire_vector)

            # Biot-Savart law
            return scipy.constants.mu_0 * np.cross(
                self.current(),
                scipy.integrate.quad_vec(
                    r() / np.linalg.norm(r()) ** 3,
                    0,
                    self.get_total_length(),
                    args=(self.points[i])
                )
            ) / 4 * scipy.constants.pi


if __name__ == '__main__':
    points = np.array(
        (
            (0, 0, 0),
            (1, 0, 0)
        )
    )

    wire = Wire(points, 1.0)
    print(wire.get_total_length())
    print(wire.get_electromotive_force((), np.array((1, 0, 0))))
